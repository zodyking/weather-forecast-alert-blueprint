blueprint:
  name: Weather — Forecast TTS (AI Optional)
  description: |
    Speak a concise, TV-weatherman-style forecast to one or more speakers on a schedule.
    Pulls daily + hourly forecasts, mentions likely rain/snow with daypart and %, and (optionally) rewrites the message via an AI Task without changing facts.

    Tips:
    • Works best with a weather provider that supports `weather.get_forecasts` (daily + hourly).
    • Set “Precipitation probability threshold” and “Hours ahead” to control if/when precip is mentioned.
    • If you turn off “Use AI rewrite,” the raw crafted message is spoken.

  domain: automation
  source_url: https://github.com/zodyking/oil-diffuser-blueprint/blob/main/oil-diffuser-ai.yaml

  input:
    weather_entity:
      name: Weather entity (with forecast)
      description: |
        Select the weather entity that this blueprint reads from. It **must** support the `weather.get_forecasts` service
        for both **daily** and **hourly** data (the blueprint calls each). Examples: `weather.home`, `weather.forecast_home`.
        If unsupported or unavailable, the spoken result may be “Forecast not available.”
      selector:
        entity:
          domain: weather

    # Scheduling
    hour_pattern:
      name: Trigger — hour pattern
      description: |
        Controls **which hours** the automation is eligible to run, using the `time_pattern` hour field.
        • `/1` → every hour (recommended)
        • `/2` → every 2 hours, `/3` → every 3 hours, etc.
        • `9` → only at 9 AM local time
        This combines with “Trigger — minute of hour,” the active time window, and weekdays.
      default: "/1"
      selector:
        text: {}

    minute_mark:
      name: Trigger — minute of hour
      description: |
        The minute within each eligible hour when this runs (string `00`–`59`). Example: `"3"` means it fires at `HH:03`.
        This is helpful to stagger multiple scheduled automations (e.g., news at :00, weather at :03).
      default: "3"
      selector:
        text: {}

    start_time:
      name: Active from (time)
      description: |
        Daily **start** of the active window in local time. The automation will only run **after** this time **and**
        before “Active until.” Keep this earlier than “Active until.” Example: `09:00:00`.
      default: "09:00:00"
      selector:
        time: {}

    end_time:
      name: Active until (time)
      description: |
        Daily **end** of the active window in local time. The automation will only run before this time.
        Keep this **later** than “Active from.” Example: `22:00:00`. (If you set `end` earlier than `start`,
        nothing will run because both conditions must be true.)
      default: "22:00:00"
      selector:
        time: {}

    weekdays:
      name: Active weekdays
      description: |
        Which days of the week this is allowed to run. Include all you want (e.g., Mon–Fri only for a commute briefing,
        or all seven for daily coverage). Must include at least one day or it will never run.
      default:
        - sun
        - mon
        - tue
        - wed
        - thu
        - fri
        - sat
      selector:
        select:
          multiple: true
          mode: list
          options:
            - sun
            - mon
            - tue
            - wed
            - thu
            - fri
            - sat

    # Forecast logic tuning
    precip_threshold:
      name: Precipitation probability threshold (%)
      description: |
        Minimum **precipitation_probability** (0–100) in the next “Hours ahead” window required to mention rain/snow.
        Example: `40` means only announce if any hourly forecast has ≥40% chance. Set `0` to mention any predicted precip.
      default: 40
      selector:
        number:
          min: 0
          max: 100
          step: 1
          unit_of_measurement: "%"

    hours_ahead:
      name: Hours ahead to scan for precip
      description: |
        How far into the future (in hours) to scan the hourly forecast for precipitation probability. Larger windows
        catch more possibilities but can be less relevant for immediate plans. Typical: `12–24`. Max here is `48`.
      default: 24
      selector:
        number:
          min: 1
          max: 48
          step: 1

    # AI rewrite (optional)
    enable_ai:
      name: Use AI rewrite
      description: |
        If **on**, the crafted message is sent to your **AI Task** entity for a concise, broadcast-style rewrite.
        If **off**, the original message is spoken as built (no AI step). Turning this off is useful if the AI service
        is unavailable or you prefer the raw phrasing.
      default: true
      selector:
        boolean: {}

    ai_task_entity:
      name: AI Task entity
      description: |
        The AI Task entity that will process the rewrite (e.g., `ai_task.google_ai_task_2`). Required **only if**
        “Use AI rewrite” is on. The blueprint calls `ai_task.generate_data` with your instructions and the built message.
        If this entity is missing or fails, it falls back to the original message.
      selector:
        entity:
          domain: ai_task

    ai_instructions:
      name: AI rewrite instructions
      description: |
        The **system prompt** sent to your AI Task. The blueprint appends the original message after this prompt under
        “Message:". Keep this strict to avoid the AI changing facts. The default prompt enforces exact facts,
        raw text output, and brevity.
      default: |
        Rewrite the message below for clear, natural TTS in a crisp TV-meteorologist voice.

        Hard rules:
        • Preserve every fact exactly: all numbers, units (°, %, mph), times, day names, and weather terms.
        • Do not invent, omit, reorder, round, or restate any facts. Keep original sequencing of info.
        • Output RAW TEXT ONLY — no quotes, code fences, YAML/JSON, greetings, preambles, or sign-offs.
        • 2–4 short sentences, ≤55 words, plain vocabulary, no emojis, no hashtags, no ALL CAPS.
        • If precipitation timing/probability exists, mention it once using the same daypart/time and %; otherwise omit.
        • Keep symbols and formatting as given (°, %, AM/PM). If the input is “Forecast not available.” return it unchanged.
      selector:
        text:
          multiline: true

    # TTS and output
    tts_engine:
      name: TTS engine entity
      description: |
        The TTS entity to use for speaking, e.g., `tts.piper`. Must support the `tts.speak` service. Some engines may
        ignore the `voice` option. If unsupported, nothing will be spoken.
      selector:
        entity:
          domain: tts

    speakers:
      name: Speaker(s)
      description: |
        One or more `media_player` entities that will play the TTS. The blueprint sets volume once on **all** selected
        speakers, then speaks to **each speaker individually**. If you use grouped speakers, prefer targeting the group
        entity to keep volumes consistent.
      selector:
        entity:
          domain: media_player
          multiple: true

    pre_speak_volume:
      name: Pre-speak volume level
      description: |
        Volume (0.00–1.00) to set on all selected speakers **just before** speaking (via `media_player.volume_set`).
        Useful to ensure audibility. If you don’t want volume changes, pick your normal listening level here or adjust
        your media players separately.
      default: 0.6
      selector:
        number:
          min: 0
          max: 1
          step: 0.01
          mode: slider

    tts_cache:
      name: Cache TTS audio
      description: |
        If **on**, lets the TTS engine reuse previously generated audio for identical messages, which can reduce latency
        and load. If your engine doesn’t support caching, this is simply ignored.
      default: true
      selector:
        boolean: {}

    tts_voice:
      name: TTS voice (if supported)
      description: |
        Voice identifier for your TTS engine (e.g., Piper `en_US-carlin-high`). Engines that don’t support voice
        selection will ignore this. Leave as default or set a preferred voice.
      default: "en_US-carlin-high"
      selector:
        text: {}

mode: single

triggers:
  - trigger: time_pattern
    hours: !input hour_pattern
    minutes: !input minute_mark

conditions:
  - condition: time
    after: !input start_time
    before: !input end_time
    weekday: !input weekdays

actions:
  # 1) Get daily forecast
  - action: weather.get_forecasts
    target:
      entity_id: !input weather_entity
    data:
      type: daily
    response_variable: d

  # 2) Get hourly forecast
  - action: weather.get_forecasts
    target:
      entity_id: !input weather_entity
    data:
      type: hourly
    response_variable: h

  # 3) Build the message
  - variables:
      key: !input weather_entity
      precip_threshold: !input precip_threshold
      hours_ahead: !input hours_ahead

      now_hour: "{{ now().hour }}"
      day_name: "{{ (now() | as_timestamp | timestamp_custom('%A', true)) }}"
      greeting: >-
        {% if 5 <= now_hour <= 11 %}Good morning{% elif 12 <= now_hour <= 17 %}
        Good afternoon{% else %}Good evening{% endif %}

      now_temp: "{{ state_attr(key,'temperature') }}"
      now_hum: "{{ state_attr(key,'humidity') }}"
      now_cond_h: >-
        {% set s = (states(key) or '') | lower %}
        {% set s = s | replace('_',' ') | replace('-',' ') %}
        {% set s = s | replace('partlycloudy','partly cloudy') | replace('clearnight','clear night') %}
        {{ s | trim }}

      daily_list: "{{ d.get(key,{}).get('forecast',[]) }}"
      today: "{{ daily_list[0] if daily_list|length>0 else dict() }}"
      high: "{{ today.get('temperature') }}"
      low: "{{ today.get('templow', today.get('temperature_low')) }}"
      today_cond_h: >-
        {% set raw = (today.get('condition') or states(key) or '') | lower %}
        {% set s = raw | replace('_',' ') | replace('-',' ') %}
        {% set s = s | replace('partlycloudy','partly cloudy') | replace('clearnight','clear night') %}
        {{ s | trim }}

      now_norm: "{{ now_cond_h | replace(' ','') }}"
      today_norm: "{{ today_cond_h | replace(' ','') }}"
      mention_expect: "{{ today_cond_h != '' and today_norm != now_norm }}"

      hourly_list: "{{ h.get(key,{}).get('forecast',[]) }}"
      next_hours: "{{ hourly_list[:hours_ahead] if hourly_list else [] }}"
      hits: >-
        {{ (next_hours
            | selectattr('precipitation_probability','defined')
            | selectattr('precipitation_probability','ge', precip_threshold)
            | list) }}
      first_hit: "{{ hits[0] if hits|length>0 else dict() }}"
      hit_pp: "{{ first_hit.get('precipitation_probability') }}"
      hit_cond_h: >-
        {% set raw = (first_hit.get('condition','') | lower) %}
        {% set s = raw | replace('_',' ') | replace('-',' ') %}
        {% set s = s | replace('partlycloudy','partly cloudy') | replace('clearnight','clear night') %}
        {{ s | trim }}
      hit_ts: >-
        {% set t = none %}
        {% if first_hit.get('datetime') %}
          {% set t = as_datetime(first_hit.get('datetime')) | as_timestamp %}
        {% endif %}
        {{ t }}
      hit_clock: >-
        {% set out = '' %}
        {% if hit_ts is not none %}
          {% set out = (hit_ts | timestamp_custom('%I %p', true)) | replace(' 0',' ') %}
        {% endif %}
        {{ out }}
      hit_hour_num: >-
        {% set out = 0 %}
        {% if hit_ts is not none %}
          {% set out = (hit_ts | timestamp_custom('%H', true)) | int %}
        {% endif %}
        {{ out }}
      hit_daypart: >-
        {% set hnum = hit_hour_num %}
        {% if 5 <= hnum <= 11 %}this morning{% elif 12 <= hnum <= 17 %}this afternoon
        {% elif 18 <= hnum <= 22 %}this evening{% else %}overnight{% endif %}

      precip_kind: >-
        {% if 'snow' in hit_cond_h %}snow{% elif 'sleet' in hit_cond_h or 'hail' in hit_cond_h %}mixed precipitation
        {% elif hit_cond_h %}rain{% else %}precipitation{% endif %}

      msg: >-
        {% set p = [] %}
        {% set p = p + [greeting ~ '! ' ~ day_name ~ "'s forecast."] %}

        {% set now_bits = [] %}
        {% if now_cond_h %}{% set now_bits = now_bits + [now_cond_h | capitalize] %}{% endif %}
        {% if now_temp is not none %}{% set now_bits = now_bits + [ (now_temp | round(0) ~ '°') ] %}{% endif %}
        {% if now_hum  is not none %}{% set now_bits = now_bits + [ ('humidity ' ~ now_hum ~ '%') ] %}{% endif %}
        {% if now_bits | length > 0 %}{% set p = p + ['Right now: ' ~ (now_bits | join(', ')) ~ '.'] %}{% endif %}

        {% set today_bits = [] %}
        {% if mention_expect %}{% set today_bits = today_bits + ['Expect ' ~ today_cond_h ~ '.'] %}{% endif %}
        {% if high is not none %}{% set today_bits = today_bits + ['High ' ~ (high | round(0)) ~ '°.'] %}{% endif %}
        {% if low  is not none %}{% set today_bits = today_bits + ['Low '  ~ (low  | round(0)) ~ '°.'] %}{% endif %}
        {% if today_bits | length > 0 %}{% set p = p + [ today_bits | join(' ') ] %}{% endif %}

        {% if hits | length > 0 and hit_pp is not none %}
          {% set phr = precip_kind ~ ' chances ' ~ hit_daypart %}
          {% if hit_clock %}{% set phr = phr ~ ' around ' ~ hit_clock %}{% endif %}
          {% set phr = phr ~ ': ' ~ (hit_pp | int) ~ '%.' %}
          {% set p = p + [ phr ] %}
        {% endif %}

        {{ p | join(' ') if p|length > 0 else 'Forecast not available.' }}

      # blueprint inputs captured as variables for templating
      i_ai: !input enable_ai
      i_ai_task: !input ai_task_entity
      i_ai_text: !input ai_instructions

  # 4) Optionally rewrite via AI Task
  - choose:
      - conditions:
          - condition: template
            value_template: "{{ i_ai and (i_ai_task | default('') | string) != '' }}"
        sequence:
          - action: ai_task.generate_data
            target:
              entity_id: !input ai_task_entity
            data:
              task_name: weather message
              instructions: |-
                {{ i_ai_text }}

                Message:
                "{{ msg | replace('"','\\"') }}"
            response_variable: aimsg
          - variables:
              spoken: "{{ aimsg.data }}"
    default:
      - variables:
          spoken: "{{ msg }}"

  # 5) Set pre-speak volume on all speakers
  - action: media_player.volume_set
    target:
      entity_id: !input speakers
    data:
      volume_level: !input pre_speak_volume

  # 6) Speak to each selected speaker
  - repeat:
      for_each: !input speakers
      sequence:
        - action: tts.speak
          target:
            entity_id: !input tts_engine
          data:
            cache: !input tts_cache
            media_player_entity_id: "{{ repeat.item }}"
            message: "{{ spoken }}"
            options:
              voice: !input tts_voice
